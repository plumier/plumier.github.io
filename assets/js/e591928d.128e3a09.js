(self.webpackChunkplumier_docs=self.webpackChunkplumier_docs||[]).push([[382],{876:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),u=s(n),d=a,f=u["".concat(l,".").concat(d)]||u[d]||m[d]||i;return n?r.createElement(f,o(o({ref:t},c),{},{components:n})):r.createElement(f,o({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:a,o[1]=p;for(var s=2;s<i;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2125:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return p},metadata:function(){return l},toc:function(){return s},default:function(){return m}});var r=n(7560),a=n(8283),i=(n(2784),n(876)),o=["components"],p={id:"reflection-basic",title:"Reflection Fundamentals"},l={unversionedId:"reflection-basic",id:"reflection-basic",isDocsHomePage:!1,title:"Reflection Fundamentals",description:"If you're coming from a static types language such as C# or Java you may found that TypeScript reflection is quite odd, since its only supported reflection using decorators, thus TypeScript unable to use reflection as automatic as C# or Java.",source:"@site/docs/Reflection.md",sourceDirName:".",slug:"/reflection-basic",permalink:"/reflection-basic",editUrl:"https://github.com/plumier/plumier/edit/master/docs/docusaurus/docs/Reflection.md",version:"current",frontMatter:{id:"reflection-basic",title:"Reflection Fundamentals"},sidebar:"overview",previous:{title:"Overview",permalink:"/extend"},next:{title:"Metaprogramming",permalink:"/metaprogramming"}},s=[{value:"Problem with Property Fields",id:"problem-with-property-fields",children:[]},{value:"Problem With Data Type Information",id:"problem-with-data-type-information",children:[]},{value:"Problem With Generic Data Type",id:"problem-with-generic-data-type",children:[]}],c={toc:s};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"If you're coming from a static types language such as C# or Java you may found that TypeScript reflection is quite odd, since its only supported reflection using decorators, thus TypeScript unable to use reflection as automatic as C# or Java. "),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Plumier uses dedicated reflection library ",(0,i.kt)("inlineCode",{parentName:"p"},"@plumier/reflect"),", that make it possible to extract type information statically."))),(0,i.kt)("p",null,"This documentation Explain about above limitation and how we commonly resolved those issue using decorators in TypeScript. By understanding its limitation, you will able to use Plumier components properly."),(0,i.kt)("h2",{id:"problem-with-property-fields"},"Problem with Property Fields"),(0,i.kt)("p",null,"JavaScript uses property fields dynamically, its make it impossible for framework to get the property information statically. Thus its required to use at least one decorator on property field declaration like below"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'import { noop } from "@plumier/reflect"\n\nclass AnimalModel {\n    @noop()\n    id:number \n\n    @noop()\n    name:string\n}\n')),(0,i.kt)("p",null,"Above code showing that we decorate each class properties with decorators. ",(0,i.kt)("inlineCode",{parentName:"p"},"@noop()")," decorator actually does nothing except to get the information of the property statically. "),(0,i.kt)("p",null,"If you are using ",(0,i.kt)("inlineCode",{parentName:"p"},"strict:true")," TypeScript configuration its impossible to define property without initialization. Its possible to use constructor property for property declaration like below"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'import { parameterProperties } from "@plumier/reflect"\n\n@parameterProperties()\nclass AnimalModel {\n    constructor(\n        public id:number,\n        public name:string\n    ){}\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"@parameterProperties()")," will tell reflection that all constructor parameter is parameter property. Plumier has ",(0,i.kt)("inlineCode",{parentName:"p"},"@domain()")," decorator which is just an alias of ",(0,i.kt)("inlineCode",{parentName:"p"},"@parameterProperties()"),", so they can be used appropriately. "),(0,i.kt)("h2",{id:"problem-with-data-type-information"},"Problem With Data Type Information"),(0,i.kt)("p",null,"TypeScript provided ",(0,i.kt)("inlineCode",{parentName:"p"},"emitDecoratorMetadata")," to emit type information on decorated declaration. Its make it possible to get data type information of properties, parameters and method return type. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'import { noop } from "@plumier/reflect" \n\nclass AnimalRepository {\n\n    @noop()\n    get(type:string): Animal{\n        return \n    }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"@noop()")," decorator above the ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," method will persist the data type information of the ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," method such as ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," parameter data type, and its return value data type."),(0,i.kt)("h2",{id:"problem-with-generic-data-type"},"Problem With Generic Data Type"),(0,i.kt)("p",null,"Decorator possible to provide data type like explained above, but it unable to provide further information of generic data type such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Array<number>")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Partial<Animal>"),". Reflection provided decorator to define data type using ",(0,i.kt)("inlineCode",{parentName:"p"},"@type()")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'import { noop } from "@plumier/reflect" \n\nclass AnimalRepository {\n\n    @type([Animal])\n    get(type:string): Animals[]{\n        return \n    }\n}\n')),(0,i.kt)("p",null,"Above code showing that we decorate the ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," method with ",(0,i.kt)("inlineCode",{parentName:"p"},"@type([Animal])"),", which informed reflection that the return type of the method is Array of Animal. Notice that tuple used for array type ",(0,i.kt)("inlineCode",{parentName:"p"},"[Animal]"),"."),(0,i.kt)("p",null,"This behavior also required on property with data type array "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'import { noop, type } from "@plumier/reflect"\n\nclass AnimalModel {\n    @noop()\n    id:number \n\n    @type([String])\n    tags:string[]\n}\n')),(0,i.kt)("p",null,"Above showing that we use ",(0,i.kt)("inlineCode",{parentName:"p"},"@type([String])")," above the ",(0,i.kt)("inlineCode",{parentName:"p"},"tags")," property which is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"string[]"),". Note that the type used is the string constructor ",(0,i.kt)("inlineCode",{parentName:"p"},"[String]")," (capitalized) instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"[string]"),"."),(0,i.kt)("p",null,"Its also required when using parameter properties like below "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'import { parameterProperties } from "@plumier/reflect"\n\n@parameterProperties()\nclass AnimalModel {\n    constructor(\n        public id:number,\n        @type([String])\n        public tags:string[]\n    ){}\n}\n')))}m.isMDXComponent=!0}}]);